<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topological Sorting Visualizer</title>
    <link rel="stylesheet" href="style.css"/>
</head>
<body>
    <div class="container">
        <div class="header-nav">
            <h1 id="main-title">üß† Topological Sorting Theory</h1>
            <div class="nav-toggle-group">
                <button class="toggle-btn active" id="theory-btn" onclick="showView('theory')">Theory</button>
                <button class="toggle-btn" id="visualizer-btn" onclick="showView('visualizer')">Visualizer</button>
            </div>
        </div>

        <!-- Visualizer View -->
        <div id="visualizer-view" style="display: none;">
            <p class="subtitle">Animated step-by-step visualization of DFS and BFS topological sorting</p>

            <div class="controls">
                <div class="input-group">
                    <label for="graphInput">Graph Input</label>
                    <div class="input-toggle">
                        <button class="toggle-btn active" id="listBtn" onclick="setInputMode('list')">Adjacency List</button>
                        <button class="toggle-btn" id="matrixBtn" onclick="setInputMode('matrix')">Adjacency Matrix</button>
                    </div>
                    <textarea id="graphInput" rows="6" placeholder="0: 1,2
1: 3
2: 3
3: 4
4:">0: 1,2
1: 3
2: 3
3: 4
4:</textarea>
                </div>
                <div class="input-group">
                    <label>Generate Random Graph</label>
                    <div class="random-controls">
                        <input type="number" id="numNodes" value="8" min="2" max="20" placeholder="Nodes">
                        <input type="number" id="numEdges" value="10" min="1" max="50" placeholder="Edges">
                        <button class="btn-secondary" onclick="generateRandomGraph()">Generate</button>
                    </div>
                </div>
                <div class="input-group">
                    <label>Algorithm</label>
                    <div class="toggle-group">
                        <button class="toggle-btn active" id="dfsBtn" onclick="setAlgorithm('dfs')">DFS</button>
                        <button class="toggle-btn" id="bfsBtn" onclick="setAlgorithm('bfs')">BFS (Kahn's)</button>
                    </div>
                    <label style="margin-top: 15px;">Animation Speed/Step</label>
                    <div class="speed-control">
                        <input type="range" id="speedSlider" min="100" max="2000" value="800" step="100">
                        <span id="speedLabel">0.8s</span>
                    </div>
                </div>
            </div>

            <div class="button-group">
                <button class="btn-primary" id="startBtn" onclick="startVisualization()">Start Visualization</button>
                <button class="btn-success" id="pauseBtn" onclick="togglePause()" disabled>Pause</button>
                <button class="btn-success" id="nextBtn" onclick="nextStep()" disabled>Next Step</button>
                <button class="btn-secondary" onclick="resetVisualization()">Reset</button>
                <button class="btn-secondary" onclick="clearGraph()">Clear</button>
            </div>

            <div class="main-content">
                <div class="visualization">
                    <canvas id="canvas" width="1000" height="700"></canvas>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-color" style="background: #6c757d;"></div><span>Unvisited</span></div>
                        <div class="legend-item"><div class="legend-color" style="background: #ffc107;"></div><span>Visiting</span></div>
                        <div class="legend-item"><div class="legend-color" style="background: #28a745;"></div><span>Processed</span></div>
                        <div class="legend-item"><div class="legend-color" style="background: #667eea;"></div><span>In Stack/Queue</span></div>
                    </div>
                </div>

                <div class="pseudocode-container">
                    <h3>üìù Pseudocode</h3>
                    <div id="dfs-pseudo">
                        <p data-line="1"><b>procedure</b> DFS_TopologicalSort(graph):</p>
                        <p data-line="2" style="padding-left: 1em;">stack &larr; empty</p>
                        <p data-line="3" style="padding-left: 1em;">visited &larr; empty set</p>
                        <p data-line="4" style="padding-left: 1em;"><b>for each</b> node <b>in</b> graph:</p>
                        <p data-line="5" style="padding-left: 2em;"><b>if</b> node is not visited:</p>
                        <p data-line="6" style="padding-left: 3em;">DFS_Visit(node, visited, stack)</p>
                        <p data-line="7" style="padding-left: 1em;"><b>return</b> reversed stack</p>
                        <br>
                        <p data-line="8"><b>procedure</b> DFS_Visit(node, visited, stack):</p>
                        <p data-line="9" style="padding-left: 1em;">mark node as visited</p>
                        <p data-line="10" style="padding-left: 1em;"><b>for each</b> neighbor <b>of</b> node:</p>
                        <p data-line="11" style="padding-left: 2em;"><b>if</b> neighbor is not visited:</p>
                        <p data-line="12" style="padding-left: 3em;">DFS_Visit(neighbor, visited, stack)</p>
                        <p data-line="13" style="padding-left: 1em;">push node onto stack</p>
                    </div>
                    <div id="bfs-pseudo" style="display: none;">
                        <p data-line="1"><b>procedure</b> Kahns_TopologicalSort(graph):</p>
                        <p data-line="2" style="padding-left: 1em;">in_degree &larr; array initialized to 0</p>
                        <p data-line="3" style="padding-left: 1em;"><b>for each</b> node <b>in</b> graph:</p>
                        <p data-line="4" style="padding-left: 2em;"><b>for each</b> neighbor <b>of</b> node:</p>
                        <p data-line="5" style="padding-left: 3em;">in_degree[neighbor]++</p>
                        <p data-line="6" style="padding-left: 1em;">queue &larr; all nodes with in_degree 0</p>
                        <p data-line="7" style="padding-left: 1em;">result &larr; empty list</p>
                        <p data-line="8" style="padding-left: 1em;"><b>while</b> queue is not empty:</p>
                        <p data-line="9" style="padding-left: 2em;">node &larr; queue.dequeue()</p>
                        <p data-line="10" style="padding-left: 2em;">add node to result</p>
                        <p data-line="11" style="padding-left: 2em;"><b>for each</b> neighbor <b>of</b> node:</p>
                        <p data-line="12" style="padding-left: 3em;">in_degree[neighbor]--</p>
                        <p data-line="13" style="padding-left: 3em;"><b>if</b> in_degree[neighbor] == 0:</p>
                        <p data-line="14" style="padding-left: 4em;">queue.enqueue(neighbor)</p>
                        <p data-line="15" style="padding-left: 1em;"><b>if</b> result has all nodes:</p>
                        <p data-line="16" style="padding-left: 2em;"><b>return</b> result</p>
                        <p data-line="17" style="padding-left: 1em;"><b>else</b>: return error (cycle detected)</p>
                    </div>
                </div>

                <div class="log-container">
                    <h3>üìã Step-by-Step Log</h3>
                    <div id="logContent"></div>
                </div>
            </div>

            <div id="result"></div>
        </div>

        <!-- Theory View -->
        <div id="theory-view">
             <p class="subtitle">Understanding the concepts behind topological sorting algorithms</p>

            <div class="theory-content">
                <section id="introduction">
                    <h2>What is Topological Sorting?</h2>
                    <div class="card">
                        <p>
                            Topological sorting provides a <strong>linear ordering</strong> of the nodes in a Directed Acyclic Graph (DAG). For every directed edge from node <code>u</code> to node <code>v</code>, node <code>u</code> must come before node <code>v</code> in the ordering. This is not a typical sorting algorithm that arranges items in numerical or alphabetical order; instead, it arranges nodes based on their dependencies.
                        </p>
                        <p>
                            Think of it as creating a valid to-do list from a set of tasks where some tasks are prerequisites for others. For example, you must put on your socks before your shoes. Topological sorting gives you a valid sequence to complete all tasks.
                        </p>
                        <h3>What is a Directed Acyclic Graph (DAG)?</h3>
                        <p>
                            A topological sort can only be performed on a <strong>Directed Acyclic Graph (DAG)</strong>. A DAG is a type of graph that has two key properties:
                        </p>
                        <ul>
                            <li><strong>Directed:</strong> All edges have a direction, representing a one-way relationship or dependency. For example, an edge from Task A to Task B means A must be completed before B can start.</li>
                            <li><strong>Acyclic:</strong> The graph contains no cycles. This means you can never start at a node, follow a sequence of directed edges, and end up back at the same starting node. This property is crucial because a cycle would represent a paradox (e.g., Task A depends on B, and B depends on A), making a linear ordering impossible.</li>
                        </ul>
                        <p>
                           It's important to note that a DAG can have multiple valid topological orderings. For instance, if two tasks have no dependency on each other, they can appear in any order relative to one another in the sorted list.
                        </p>
                    </div>
                </section>
                
                <section id="kahns-algorithm">
                    <h2>Kahn's Algorithm (BFS Approach)</h2>
                    <div class="card">
                        <h3>How It Works</h3>
                        <p>
                            Kahn's algorithm is a Breadth-First Search (BFS) based approach. It works by identifying nodes that have no incoming edges (in-degree of 0). These nodes can safely be placed first in the sorted order. The algorithm then "removes" these nodes and their outgoing edges from the graph. This may, in turn, reduce the in-degree of other nodes, potentially making them the new nodes with an in-degree of 0. This process is repeated until all nodes are visited.
                        </p>
                        <h3>Algorithm Steps</h3>
                        <ol>
                            <li><strong>Compute In-Degrees:</strong> Calculate the in-degree for every vertex in the graph.</li>
                            <li><strong>Initialize Queue:</strong> Add all vertices with an in-degree of 0 to a queue.</li>
                            <li><strong>Process Nodes:</strong> While the queue is not empty:
                                <ol type="a">
                                    <li>Dequeue a vertex <code>u</code>. Add <code>u</code> to the result list.</li>
                                    <li>For each neighbor <code>v</code> of <code>u</code>:
                                        <ul>
                                            <li>Decrement the in-degree of <code>v</code>.</li>
                                            <li>If the in-degree of <code>v</code> becomes 0, enqueue <code>v</code>.</li>
                                        </ul>
                                    </li>
                                </ol>
                            </li>
                            <li><strong>Check for Cycle:</strong> If the count of nodes in the result list is less than the total number of nodes in the graph, a cycle exists.</li>
                        </ol>
                        <h3>Live Visualization</h3>
                        <p>
                            The <a href="#" onclick="switchToVisualizer('bfs')">BFS visualization</a> on the main page demonstrates this process. It highlights the nodes being added to the queue and processed, showing how the in-degrees of their neighbors are updated in real-time.
                        </p>
                    </div>
                </section>
    
                <section id="dfs-approach">
                    <h2>DFS Approach</h2>
                    <div class="card">
                        <h3>How It Works</h3>
                        <p>
                            The Depth-First Search (DFS) approach is another way to perform topological sorting. This method explores the graph as deeply as possible along each branch before backtracking. The key idea is to push a vertex to a stack only after all its adjacent vertices (and their descendants) have been visited. The final topological order is the reverse of the order in which the vertices were pushed onto the stack.
                        </p>
                        <h3>Algorithm Steps</h3>
                        <ol>
                            <li><strong>Initialize:</strong> Create an empty stack to store the sorted nodes and a set to track visited nodes.</li>
                            <li><strong>Iterate and Recurse:</strong> For each unvisited vertex <code>u</code> in the graph, call a recursive DFS helper function on <code>u</code>.</li>
                            <li><strong>DFS Helper Function (<code>dfs(u)</code>):</strong>
                                <ol type="a">
                                    <li>Mark <code>u</code> as visited and add it to the current recursion stack (to detect cycles).</li>
                                    <li>For each neighbor <code>v</code> of <code>u</code>:
                                        <ul>
                                            <li>If <code>v</code> is on the current recursion stack, a cycle is detected.</li>
                                            <li>If <code>v</code> is not visited, recursively call <code>dfs(v)</code>.</li>
                                        </ul>
                                    </li>
                                    <li>Remove <code>u</code> from the recursion stack.</li>
                                    <li>Push <code>u</code> onto the main stack.</li>
                                </ol>
                            </li>
                            <li><strong>Final Result:</strong> Once the iteration is complete, pop all items from the stack to get the final topological order.</li>
                        </ol>
                         <h3>Live Visualization</h3>
                        <p>
                            Our <a href="#" onclick="switchToVisualizer('dfs')">DFS visualizer</a> provides a step-by-step animation of this recursive process. It shows nodes being visited, processed, and added to the stack.
                        </p>
                    </div>
                </section>
    
                <section id="compare">
                    <h2>Compare & Choose: BFS vs. DFS</h2>
                    <div class="card">
                        <h3>BFS vs. DFS</h3>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th>Kahn's Algorithm (BFS)</th>
                                    <th>DFS-Based Algorithm</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Core Idea</strong></td>
                                    <td>Processes nodes with no incoming dependencies first.</td>
                                    <td>Processes a node after all its dependencies have been processed.</td>
                                </tr>
                                <tr>
                                    <td><strong>Data Structure</strong></td>
                                    <td>Queue</td>
                                    <td>Stack (often via recursion call stack)</td>
                                </tr>
                                <tr>
                                    <td><strong>Output Order</strong></td>
                                    <td>The resulting order is lexicographically smallest if the queue is managed like a min-priority queue.</td>
                                    <td>The order depends on the starting nodes and traversal path.</td>
                                </tr>
                                 <tr>
                                    <td><strong>Cycle Detection</strong></td>
                                    <td>A cycle is detected if the final result has fewer nodes than the graph.</td>
                                    <td>A cycle is detected if a "back edge" is found to a node in the current recursion stack.</td>
                                </tr>
                            </tbody>
                        </table>
                        <h3>When to Use Which</h3>
                        <ul>
                            <li>Use <strong>Kahn's Algorithm (BFS)</strong> when you need the resulting order to be lexicographically sorted, as you can use a min-priority queue instead of a regular queue. It's also more intuitive for understanding task dependencies.</li>
                            <li>Use the <strong>DFS approach</strong> when you have a graph represented in a way that's naturally suited for recursion, or if you prefer a more straightforward implementation without the need to pre-calculate in-degrees.</li>
                        </ul>
                        <h3>Performance</h3>
                        <p>
                            Both algorithms have the same time complexity: <strong>O(V + E)</strong>, where <code>V</code> is the number of vertices and <code>E</code> is the number of edges.
                            This is because both methods must visit every vertex and every edge exactly once. The space complexity is also <strong>O(V)</strong> to store the in-degrees/visited set and the queue/stack.
                        </p>
                    </div>
                </section>
                
                <section id="applications">
                    <h2>Real-Life Applications</h2>
                    <div class="card">
                        <p>Topological sorting is not just a theoretical concept; it's the backbone of many real-world systems that manage dependencies.</p>
                        <ul>
                            <li><strong>Task Scheduling:</strong> In project management, tasks often have dependencies. Topological sort provides a valid sequence to execute them, forming the basis for critical path analysis in PERT charts.</li>
                            <li><strong>Course Prerequisites:</strong> Universities use topological sorting to schedule courses, ensuring that a student completes all prerequisites before enrolling in an advanced course.</li>
                            <li><strong>Software Build Systems:</strong> Compilers and build tools like Make or Maven use topological sorting to determine the correct order to compile source files and link libraries based on their dependencies.</li>
                            <li><strong>Dependency Resolution:</strong> Software package managers (like npm or apt) use it to figure out the correct order to install packages and their dependencies.</li>
                            <li><strong>Data Processing & ETL Pipelines:</strong> In large-scale data processing, jobs often depend on the output of other jobs. DAGs are used to model these pipelines, and topological sort defines the execution order.</li>
                        </ul>
                    </div>
                </section>

                <section id="advantages-disadvantages">
                    <h2>Advantages & Disadvantages</h2>
                    <div class="card">
                        <h3>Advantages</h3>
                        <ul>
                            <li><strong>Simplifies Complex Dependencies:</strong> It provides a clear and linear sequence for executing tasks in systems with complex prerequisite chains.</li>
                            <li><strong>Cycle Detection:</strong> The algorithms for topological sorting naturally detect cycles, which is critical for identifying impossible dependency loops in a schedule or system.</li>
                            <li><strong>Efficiency:</strong> Both primary algorithms (Kahn's and DFS-based) are very efficient, running in linear time O(V + E).</li>
                        </ul>
                        <h3>Disadvantages</h3>
                        <ul>
                            <li><strong>Only for DAGs:</strong> Its primary limitation is that it only works on Directed Acyclic Graphs. It cannot be applied to graphs with cycles or undirected graphs.</li>
                            <li><strong>Non-Unique Results:</strong> For many graphs, there can be multiple valid topological orders. This ambiguity can be an issue if a single, specific order is required.</li>
                        </ul>
                    </div>
                </section>
            </div>
        </div>
    </div>
    <script src="script.js"></script>
</body>
</html>